//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/UIWatcherModule.kt =====
package com.jarvismini.devtools.autobuild

import android.accessibilityservice.AccessibilityService
import android.os.Bundle
import android.util.Log
import android.view.accessibility.AccessibilityNodeInfo
import kotlinx.coroutines.delay

/**
 * All UI interaction with the Claude Android app.
 *
 * Findings from uiautomator dump of com.anthropic.claude:
 *
 * RESPONSE TEXT:
 *   android.view.View [focusable=true]
 *     └── android.widget.TextView  ← prose text of Claude's reply
 *
 * CODE BLOCKS:
 *   android.view.View [focusable=true]
 *     └── android.widget.HorizontalScrollView [scrollable=true]
 *           └── android.widget.TextView  ← code content
 *     └── android.widget.TextView  ← prose continuation
 *
 *   There is NO language label node ("kotlin", "java" etc.) —
 *   code blocks are identified by their HorizontalScrollView parent.
 *
 * INPUT AREA:
 *   android.widget.EditText [focusable=true, clickable=true]
 *     hint child: TextView text="Reply to Claude…"
 *
 * ADD FILES BUTTON:
 *   android.view.View [clickable=true, focusable=true]
 *     └── android.view.View content-desc="Add to chat"
 *
 * SEND BUTTON (only present when input has text):
 *   android.view.View [clickable=true, focusable=true]
 *     └── android.view.View content-desc="Send"
 *
 * STREAMING INDICATORS: "●", "Thinking…", "Thinking...", "▌"
 *   appear as TextView text while Claude is generating.
 */
class UIWatcherModule(val service: AccessibilityService) {

    companion object {
        private const val TAG = "DevTools:UIWatcher"

        const val CLAUDE_PKG            = "com.anthropic.claude"
        const val STABILITY_WINDOW_MS   = 2_500L
        const val RESPONSE_TIMEOUT_MS   = 120_000L
        const val POST_TAP_DELAY_MS     = 900L
        const val FILE_ATTACH_DELAY_MS  = 1_600L

        val STREAMING_INDICATORS = setOf("●", "Thinking…", "Thinking...", "▌")

        // Content-desc values confirmed from uiautomator dump
        const val ADD_TO_CHAT_DESC  = "Add to chat"
        const val SEND_DESC         = "Send"
    }

    @Volatile var lastClaudeEventMs: Long = 0L

    /** Called by AutoBuildService.onAccessibilityEvent for every Claude event. */
    fun onAccessibilityEvent(packageName: String?) {
        if (packageName == CLAUDE_PKG) lastClaudeEventMs = System.currentTimeMillis()
    }

    // ── Response detection ────────────────────────────────────────────────────

    suspend fun waitForResponseComplete(timeoutMs: Long = RESPONSE_TIMEOUT_MS): Boolean {
        val deadline = System.currentTimeMillis() + timeoutMs
        delay(1_500L) // give Claude a moment to start generating

        while (System.currentTimeMillis() < deadline) {
            val elapsed = System.currentTimeMillis() - lastClaudeEventMs
            if (elapsed >= STABILITY_WINDOW_MS && !isStreamingIndicatorVisible()) {
                Log.d(TAG, "Response stable for ${elapsed}ms — complete")
                return true
            }
            delay(500L)
        }
        Log.w(TAG, "waitForResponseComplete timed out")
        return false
    }

    private fun isStreamingIndicatorVisible(): Boolean {
        val root = service.rootInActiveWindow ?: return false
        return findNodeByText(root, STREAMING_INDICATORS) != null
    }

    // ── Code extraction ───────────────────────────────────────────────────────

    /**
     * Extracts code blocks from Claude's response.
     *
     * Code blocks in Claude's UI are TextViews inside a HorizontalScrollView.
     * We walk the tree looking for HorizontalScrollView nodes and grab their
     * TextView children. Falls back to the largest TextView if none found.
     */
    fun extractCodeBlocks(root: AccessibilityNodeInfo?): List<String> {
        root ?: return emptyList()
        val blocks = mutableListOf<String>()
        collectCodeBlocks(root, blocks)

        if (blocks.isEmpty()) {
            Log.w(TAG, "No HorizontalScrollView code blocks found, trying largest TextView fallback")
            largestTextViewText(root)?.takeIf { it.isNotBlank() }?.let { blocks.add(it) }
        }

        Log.d(TAG, "Extracted ${blocks.size} code block(s)")
        return blocks
    }

    /**
     * Walks the node tree looking for HorizontalScrollView nodes.
     * Each one wraps a code block — the TextView child contains the code text.
     */
    private fun collectCodeBlocks(node: AccessibilityNodeInfo, out: MutableList<String>) {
        if (node.className?.toString() == "android.widget.HorizontalScrollView") {
            // Grab all TextView children — the code is directly inside
            for (i in 0 until node.childCount) {
                val child = node.getChild(i) ?: continue
                val text = child.text?.toString()
                if (!text.isNullOrBlank()) {
                    out.add(text)
                    Log.d(TAG, "Code block found (${text.length} chars): ${text.take(60)}…")
                }
            }
            return // don't recurse into the scrollview children again
        }
        for (i in 0 until node.childCount) {
            collectCodeBlocks(node.getChild(i) ?: continue, out)
        }
    }

    private fun largestTextViewText(root: AccessibilityNodeInfo): String? {
        var best: String? = null
        fun traverse(n: AccessibilityNodeInfo?) {
            n ?: return
            if (n.className?.toString()?.endsWith("TextView") == true) {
                val t = n.text?.toString() ?: ""
                if (t.length > (best?.length ?: 0)) best = t
            }
            for (i in 0 until n.childCount) traverse(n.getChild(i))
        }
        traverse(root)
        return best
    }

    // ── Prompt field ──────────────────────────────────────────────────────────

    /**
     * Finds the EditText (hint: "Reply to Claude…") and sets its text.
     */
    fun fillPromptField(text: String): Boolean {
        val root  = service.rootInActiveWindow ?: return false
        val input = findEditText(root) ?: run {
            Log.w(TAG, "fillPromptField: EditText not found")
            return false
        }
        val args = Bundle().apply {
            putString(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, text)
        }
        return input.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, args)
    }

    // ── Tap helpers ───────────────────────────────────────────────────────────

    /**
     * Taps the "Add to chat" button (confirmed content-desc from uiautomator dump).
     * The clickable node is the parent View wrapping the content-desc child.
     */
    suspend fun tapAddFilesButton(): Boolean {
        val root = service.rootInActiveWindow ?: return false
        // Find the inner view with content-desc="Add to chat", then click its clickable parent
        val node = findClickableParentByDesc(root, ADD_TO_CHAT_DESC) ?: run {
            Log.w(TAG, "Add to chat button not found")
            return false
        }
        return node.performAction(AccessibilityNodeInfo.ACTION_CLICK)
            .also { success ->
                Log.d(TAG, "tapAddFilesButton: $success")
                if (success) delay(FILE_ATTACH_DELAY_MS)
            }
    }

    suspend fun selectFileInPicker(fileName: String): Boolean {
        delay(POST_TAP_DELAY_MS)
        val root = service.rootInActiveWindow ?: return false
        val node = findNodeByText(root, setOf(fileName)) ?: run {
            Log.w(TAG, "File '$fileName' not visible in picker")
            return false
        }
        val clicked = node.performAction(AccessibilityNodeInfo.ACTION_CLICK)
        if (clicked) {
            delay(POST_TAP_DELAY_MS)
            confirmPickerSelection()
        }
        return clicked
    }

    private suspend fun confirmPickerSelection() {
        val root = service.rootInActiveWindow ?: return
        findNodeByText(root, setOf("Select", "Open", "Done", "OK"))
            ?.performAction(AccessibilityNodeInfo.ACTION_CLICK)
        delay(POST_TAP_DELAY_MS)
    }

    /**
     * Taps the "Send" button (confirmed content-desc from uiautomator dump).
     * Only present when there is text in the input field.
     */
    suspend fun tapSendButton(): Boolean {
        val root = service.rootInActiveWindow ?: return false
        val node = findClickableParentByDesc(root, SEND_DESC) ?: run {
            Log.w(TAG, "Send button not found (may not be visible yet)")
            return false
        }
        return node.performAction(AccessibilityNodeInfo.ACTION_CLICK)
            .also { success ->
                Log.d(TAG, "tapSendButton: $success")
                if (success) delay(POST_TAP_DELAY_MS)
            }
    }

    // ── Node search ───────────────────────────────────────────────────────────

    /**
     * Finds a node whose content-desc matches [desc], then walks UP the tree
     * to find the nearest ancestor that is clickable=true.
     * This matches Claude's pattern where the icon has the content-desc but
     * the clickable hit-area is the parent View.
     */
    private fun findClickableParentByDesc(
        root: AccessibilityNodeInfo,
        desc: String
    ): AccessibilityNodeInfo? {
        val target = findNodeByDesc(root, desc) ?: return null
        // Walk up to find clickable ancestor
        var current: AccessibilityNodeInfo? = target.parent
        while (current != null) {
            if (current.isClickable) return current
            current = current.parent
        }
        // Fallback: return the target itself if nothing clickable found above
        return if (target.isClickable) target else null
    }

    private fun findNodeByDesc(
        root: AccessibilityNodeInfo,
        desc: String
    ): AccessibilityNodeInfo? {
        val d = root.contentDescription?.toString() ?: ""
        if (d.equals(desc, ignoreCase = true)) return root
        for (i in 0 until root.childCount) {
            findNodeByDesc(root.getChild(i) ?: continue, desc)?.let { return it }
        }
        return null
    }

    private fun findNodeByText(
        root: AccessibilityNodeInfo,
        targets: Set<String>
    ): AccessibilityNodeInfo? {
        val text = root.text?.toString()?.trim() ?: ""
        if (targets.any { text.contains(it, ignoreCase = true) }) return root
        for (i in 0 until root.childCount) {
            findNodeByText(root.getChild(i) ?: continue, targets)?.let { return it }
        }
        return null
    }

    private fun findEditText(root: AccessibilityNodeInfo): AccessibilityNodeInfo? {
        if (root.className?.toString()?.endsWith("EditText") == true && root.isEditable) return root
        for (i in 0 until root.childCount) {
            findEditText(root.getChild(i) ?: continue)?.let { return it }
        }
        return null
    }
}
