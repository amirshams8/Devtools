================================
FILE TREE (SELECTED FOLDERS)
================================

.
├── app
│   ├── build.gradle.kts
│   ├── src
│   │   ├── main
│   │   │   ├── AndroidManifest.xml
│   │   │   ├── kotlin
│   │   │   │   ├── com
│   │   │   │   │   ├── jarvismini
│   │   │   │   │   │   ├── devtools
│   │   │   │   │   │   │   ├── DevToolsApp.kt
│   │   │   │   │   │   │   ├── MainActivity.kt
│   │   │   │   │   │   │   ├── autobuild
│   │   │   │   │   │   │   │   ├── AutoBuildService.kt
│   │   │   │   │   │   │   │   ├── BuildNotifier.kt
│   │   │   │   │   │   │   │   ├── FileManagerModule.kt
│   │   │   │   │   │   │   │   ├── ModeStore.kt
│   │   │   │   │   │   │   │   ├── OrchestrationController.kt
│   │   │   │   │   │   │   │   ├── TermuxBridgeModule.kt
│   │   │   │   │   │   │   │   ├── UIWatcherModule.kt
│   │   │   │   │   │   │   │   ├── models
│   │   │   │   │   │   │   │   │   ├── AutoBuildState.kt
│   │   │   │   │   │   │   │   │   ├── BuildResult.kt
│   │   │   │   │   │   │   │   │   ├── ErrorFingerprint.kt
│   │   │   │   │   │   │   │   │   ├── ErrorLogBundle.kt
│   │   │   │   │   │   │   │   │   ├── ExtractionMode.kt
│   │   │   │   │   │   │   │   │   ├── LoopState.kt
│   │   │   ├── res
│   │   │   │   ├── drawable
│   │   │   │   │   ├── circle_dot.xml
│   │   │   │   ├── layout
│   │   │   │   │   ├── activity_main.xml
│   │   │   │   ├── values
│   │   │   │   │   ├── colors.xml
│   │   │   │   │   ├── strings.xml
│   │   │   │   │   ├── themes.xml
│   │   │   │   ├── xml
│   │   │   │   │   ├── autobuild_accessibility_config.xml
├── gradle/wrapper
│   ├── gradle-wrapper.properties
├── scripts
│   ├── build_runner.sh
├── .github
│   ├── workflows
│   │   ├── Ai-codegen.yml
│   │   ├── Apk.yml
│   │   ├── Setup.yml
│   │   ├── main.yml

================================
SOURCE CODE
================================

//===== FILE: app/build.gradle.kts =====
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.jarvismini.devtools"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.jarvismini.devtools"
        minSdk = 26
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"
    }

    buildFeatures {
        viewBinding = true
        buildConfig = true
        dataBinding = false   // must be explicit — Material Components can trigger this transitively
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }

    kotlinOptions {
        jvmTarget = "17"
    }
}

dependencies {
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.appcompat:appcompat:1.6.1")
    implementation("com.google.android.material:material:1.11.0")
    implementation("androidx.constraintlayout:constraintlayout:2.1.4")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
}


//===== FILE: app/src/main/AndroidManifest.xml =====
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Storage: read error logs from /sdcard/ai-automation/ -->
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"
        android:maxSdkVersion="32" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"
        android:maxSdkVersion="32" />
    <uses-permission
        android:name="android.permission.MANAGE_EXTERNAL_STORAGE"
        tools:ignore="ScopedStorage" />

    <!-- Foreground service for the build loop -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_DATA_SYNC" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

    <!-- Termux RUN_COMMAND: git push ai-output.txt and git pull error logs -->
    <uses-permission android:name="com.termux.permission.RUN_COMMAND" />

    <queries>
        <!-- Termux: for git push/pull via RUN_COMMAND intent -->
        <package android:name="com.termux" />
        <!-- Claude: accessibility service target -->
        <package android:name="com.anthropic.claude" />
    </queries>

    <application
        android:name=".DevToolsApp"
        android:allowBackup="false"
        android:label="@string/app_name"
        android:theme="@style/Theme.DevTools"
        android:requestLegacyExternalStorage="true">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:windowSoftInputMode="adjustResize">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!--
            AutoBuildService: AccessibilityService that watches Claude app,
            extracts code responses, and drives the CI loop.
            Enable in: Android Settings → Accessibility → DevTools → AutoBuild Service
        -->
        <service
            android:name=".autobuild.AutoBuildService"
            android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"
            android:exported="true"
            android:foregroundServiceType="dataSync">
            <intent-filter>
                <action android:name="android.accessibilityservice.AccessibilityService" />
            </intent-filter>
            <meta-data
                android:name="android.accessibilityservice"
                android:resource="@xml/autobuild_accessibility_config" />
        </service>

    </application>
</manifest>


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/DevToolsApp.kt =====
package com.jarvismini.devtools

import android.app.Application
import android.app.NotificationChannel
import android.app.NotificationManager

class DevToolsApp : Application() {

    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
    }

    private fun createNotificationChannel() {
        val channel = NotificationChannel(
            CHANNEL_ID,
            "AutoBuild Service",
            NotificationManager.IMPORTANCE_LOW
        ).apply {
            description = "AutoBuild CI loop status"
            setShowBadge(false)
        }
        val nm = getSystemService(NotificationManager::class.java)
        nm.createNotificationChannel(channel)
    }

    companion object {
        const val CHANNEL_ID = "autobuild_channel"
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/MainActivity.kt =====
package com.jarvismini.devtools

import android.content.Intent
import android.graphics.Color
import android.os.Bundle
import android.provider.Settings
import android.text.Spannable
import android.text.SpannableStringBuilder
import android.text.style.ForegroundColorSpan
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import androidx.appcompat.app.AppCompatActivity
import com.jarvismini.devtools.autobuild.AutoBuildService
import com.jarvismini.devtools.autobuild.ModeStore
import com.jarvismini.devtools.autobuild.models.AutoBuildState
import com.jarvismini.devtools.autobuild.models.ExtractionMode
import com.jarvismini.devtools.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    private val logBuilder = SpannableStringBuilder()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupModeSpinner()
        setupButtons()
        registerCallbacks()
        refreshServiceState()
    }

    override fun onResume() {
        super.onResume()
        refreshServiceState()
    }

    override fun onDestroy() {
        super.onDestroy()
        AutoBuildService.onStatusUpdate = null
        AutoBuildService.onLogLine = null
    }

    // ── Mode spinner ──────────────────────────────────────────────────────────

    private fun setupModeSpinner() {
        val labels = listOf(
            "Code block in chat",
            "Downloaded file(s) → /sdcard",
            "Plain text in chat"
        )
        val adapter = ArrayAdapter(this, android.R.layout.simple_spinner_item, labels).also {
            it.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
        }
        binding.spinnerMode.adapter = adapter
        binding.spinnerMode.setSelection(ModeStore.load(this).ordinal)

        binding.spinnerMode.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(parent: AdapterView<*>, view: View?, pos: Int, id: Long) {
                val mode = ExtractionMode.entries[pos]
                ModeStore.save(this@MainActivity, mode)
                appendLog("Mode: ${mode.name}", Color.CYAN)
            }
            override fun onNothingSelected(parent: AdapterView<*>) {}
        }
    }

    // ── Buttons ───────────────────────────────────────────────────────────────

    private fun setupButtons() {
        binding.btnStart.setOnClickListener {
            startActivity(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS))
        }
        binding.btnStop.setOnClickListener {
            AutoBuildService.requestStop()
            appendLog("Stop requested by user.", Color.YELLOW)
            binding.btnStop.isEnabled = false
        }
        binding.btnAccessibility.setOnClickListener {
            startActivity(Intent(Settings.ACTION_ACCESSIBILITY_SETTINGS))
        }
    }

    // ── Service callbacks ─────────────────────────────────────────────────────

    private fun registerCallbacks() {
        AutoBuildService.onStatusUpdate = { iteration, state ->
            runOnUiThread { updateStatus(iteration, state) }
        }
        AutoBuildService.onLogLine = { line, isError ->
            runOnUiThread { appendLog(line, if (isError) Color.RED else Color.WHITE) }
        }
    }

    // ── UI helpers ────────────────────────────────────────────────────────────

    private fun refreshServiceState() {
        val enabled = isAccessibilityServiceEnabled()
        if (enabled) {
            binding.tvAccessibilityHint.visibility = View.GONE
            binding.btnStart.isEnabled = false
            binding.btnStop.isEnabled = true
            if (AutoBuildService.isLoopRunning) {
                updateStatus(AutoBuildService.currentIteration, AutoBuildService.currentState)
            }
        } else {
            binding.tvAccessibilityHint.visibility = View.VISIBLE
            binding.btnStart.isEnabled = true
            binding.btnStop.isEnabled = false
            setStatusDot(Color.GRAY)
            binding.tvStatus.text = getString(R.string.status_idle)
        }
    }

    private fun updateStatus(iteration: Int, state: AutoBuildState) {
        binding.tvIteration.text = "Iter: $iteration"
        binding.tvStatus.text = state.displayName()
        setStatusDot(state.dotColor())
    }

    private fun setStatusDot(color: Int) {
        binding.statusDot.backgroundTintList =
            android.content.res.ColorStateList.valueOf(color)
    }

    private fun appendLog(line: String, color: Int) {
        val start = logBuilder.length
        logBuilder.append(line).append("\n")
        logBuilder.setSpan(
            ForegroundColorSpan(color), start, logBuilder.length,
            Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
        )
        binding.tvLog.text = logBuilder
        binding.scrollLog.post { binding.scrollLog.fullScroll(View.FOCUS_DOWN) }
    }

    private fun isAccessibilityServiceEnabled(): Boolean {
        val enabledServices = Settings.Secure.getString(
            contentResolver, Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
        ) ?: return false
        val short = "${packageName}/.autobuild.AutoBuildService"
        val full  = "${packageName}/com.jarvismini.devtools.autobuild.AutoBuildService"
        return enabledServices.split(":").any { entry ->
            val t = entry.trim()
            t.equals(short, ignoreCase = true) || t.equals(full, ignoreCase = true)
        }
    }

    private fun AutoBuildState.displayName() = when (this) {
        AutoBuildState.IDLE                     -> "Idle"
        AutoBuildState.WAITING_FOR_RESPONSE     -> "Waiting for Claude response…"
        AutoBuildState.EXTRACTING_CODE          -> "Extracting code…"
        AutoBuildState.WRITING_OUTPUT           -> "Writing ai-output.txt…"
        AutoBuildState.TRIGGERING_BUILD         -> "Pushing to GitHub via Termux…"
        AutoBuildState.WAITING_FOR_BUILD        -> "Waiting for Apk.yml to finish…"
        AutoBuildState.CHECKING_ERROR_FRESHNESS -> "Checking if errors are new…"
        AutoBuildState.READING_ERROR_LOGS       -> "Pulling error logs…"
        AutoBuildState.ATTACHING_FILES          -> "Attaching error logs to Claude…"
        AutoBuildState.SUBMITTING_PROMPT        -> "Submitting prompt to Claude…"
        AutoBuildState.BUILD_SUCCEEDED          -> "✅ Build succeeded!"
        AutoBuildState.TIMEOUT_ERROR            -> "⚠ Timeout — retrying…"
    }

    private fun AutoBuildState.dotColor() = when (this) {
        AutoBuildState.BUILD_SUCCEEDED          -> Color.GREEN
        AutoBuildState.TIMEOUT_ERROR            -> Color.RED
        AutoBuildState.IDLE                     -> Color.GRAY
        AutoBuildState.WAITING_FOR_BUILD,
        AutoBuildState.TRIGGERING_BUILD         -> Color.YELLOW
        else                                    -> Color.CYAN
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/AutoBuildService.kt =====
package com.jarvismini.devtools.autobuild

import android.accessibilityservice.AccessibilityService
import android.app.Service
import android.content.Intent
import android.util.Log
import android.view.accessibility.AccessibilityEvent
import com.jarvismini.devtools.autobuild.models.AutoBuildState
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.launch

/**
 * AccessibilityService entry point for the AutoBuild loop.
 *
 * Enable via: Android Settings → Accessibility → DevTools → AutoBuild Service
 *
 * Static callbacks (onStatusUpdate, onLogLine) are set by MainActivity so the
 * UI receives live updates without binding to the service. They are nullable to
 * avoid memory leaks when MainActivity is destroyed.
 *
 * requestStop() sets a flag read by OrchestrationController on every iteration,
 * allowing a clean exit without killing the coroutine forcibly.
 */
class AutoBuildService : AccessibilityService() {

    companion object {
        private const val TAG = "DevTools:Service"

        /** Called on every state transition: (iteration, state) */
        var onStatusUpdate: ((Int, AutoBuildState) -> Unit)? = null

        /** Called for every log line emitted by the orchestrator: (message, isError) */
        var onLogLine: ((String, Boolean) -> Unit)? = null

        /** Weak reference to the running service instance for stop requests. */
        private var instance: AutoBuildService? = null

        /**
         * Live state snapshot — updated on every loop iteration so MainActivity
         * can display the correct status when it resumes after being in the background.
         */
        @Volatile var currentState: AutoBuildState = AutoBuildState.IDLE
        @Volatile var currentIteration: Int = 0

        /** True only while the loop coroutine is actively running. */
        val isLoopRunning: Boolean get() = instance?.loopJob?.isActive == true

        fun requestStop() {
            instance?.orchestrator?.requestStop()
            Log.d(TAG, "Stop requested")
        }
    }

    private lateinit var uiWatcher:    UIWatcherModule
    private lateinit var orchestrator: OrchestrationController
    private lateinit var notifier:     BuildNotifier

    private val scope = CoroutineScope(Dispatchers.Main)
    private var loopJob: Job? = null

    override fun onServiceConnected() {
        super.onServiceConnected()
        instance     = this
        uiWatcher    = UIWatcherModule(this)
        orchestrator = OrchestrationController(this, uiWatcher)
        notifier     = BuildNotifier(this)

        // Reset snapshot so stale state from a previous session isn't shown
        currentState     = AutoBuildState.IDLE
        currentIteration = 0

        // Clear the crash-recovery checkpoint so the loop always starts fresh
        // from WAITING_FOR_RESPONSE rather than resuming from a stale state like
        // WAITING_FOR_BUILD (which would poll forever for a flag that never arrives).
        FileManagerModule().clearCheckpoint()

        // Run as foreground service to survive long builds
        startForeground(
            BuildNotifier.NOTIFICATION_ID,
            notifier.buildNotification(0, AutoBuildState.IDLE)
        )

        loopJob = scope.launch {
            try {
                orchestrator.runLoop()
            } catch (e: Exception) {
                Log.e(TAG, "Loop crashed", e)
                notifier.error("Crashed: ${e.message}")
                onLogLine?.invoke("CRASH: ${e.message}", true)
            }
        }

        Log.i(TAG, "AutoBuildService connected and loop started")
    }

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        event ?: return
        if (::uiWatcher.isInitialized) {
            uiWatcher.onAccessibilityEvent(event.packageName?.toString())
        }
    }

    override fun onInterrupt() {
        Log.w(TAG, "Service interrupted")
        loopJob?.cancel()
    }

    override fun onUnbind(intent: Intent?): Boolean {
        instance = null
        loopJob?.cancel()
        currentState     = AutoBuildState.IDLE
        currentIteration = 0
        stopForeground(Service.STOP_FOREGROUND_REMOVE)
        return super.onUnbind(intent)
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/BuildNotifier.kt =====
package com.jarvismini.devtools.autobuild

import android.app.Notification
import android.app.NotificationManager
import android.content.Context
import android.util.Log
import com.jarvismini.devtools.DevToolsApp
import com.jarvismini.devtools.autobuild.models.AutoBuildState

/**
 * Posts and updates the persistent foreground notification.
 * Uses Android default icon — no custom drawables required.
 */
class BuildNotifier(private val context: Context) {

    companion object {
        const val NOTIFICATION_ID = 9_001
        private const val TAG     = "DevTools:Notifier"
    }

    private val nm = context.getSystemService(NotificationManager::class.java)

    fun buildNotification(iteration: Int, state: AutoBuildState): Notification =
        Notification.Builder(context, DevToolsApp.CHANNEL_ID)
            .setSmallIcon(android.R.mipmap.sym_def_app_icon)
            .setContentTitle("AutoBuild — Iter $iteration")
            .setContentText(stateText(state))
            .setOngoing(true)
            .build()

    fun update(iteration: Int, state: AutoBuildState) {
        runCatching { nm.notify(NOTIFICATION_ID, buildNotification(iteration, state)) }
            .onFailure { Log.w(TAG, "Notification update failed", it) }
    }

    fun success(iteration: Int) {
        runCatching {
            nm.notify(NOTIFICATION_ID,
                Notification.Builder(context, DevToolsApp.CHANNEL_ID)
                    .setSmallIcon(android.R.mipmap.sym_def_app_icon)
                    .setContentTitle("✅ Build Succeeded")
                    .setContentText("Done after $iteration iteration(s)")
                    .setAutoCancel(true)
                    .build()
            )
        }
    }

    fun error(msg: String) {
        runCatching {
            nm.notify(NOTIFICATION_ID,
                Notification.Builder(context, DevToolsApp.CHANNEL_ID)
                    .setSmallIcon(android.R.mipmap.sym_def_app_icon)
                    .setContentTitle("❌ AutoBuild Stopped")
                    .setContentText(msg)
                    .setAutoCancel(true)
                    .build()
            )
        }
    }

    private fun stateText(state: AutoBuildState) = when (state) {
        AutoBuildState.WAITING_FOR_RESPONSE     -> "Waiting for Claude response…"
        AutoBuildState.EXTRACTING_CODE          -> "Extracting code…"
        AutoBuildState.WRITING_OUTPUT           -> "Writing ai-output.txt…"
        AutoBuildState.TRIGGERING_BUILD         -> "Pushing via Termux…"
        AutoBuildState.WAITING_FOR_BUILD        -> "Waiting for Apk.yml…"
        AutoBuildState.CHECKING_ERROR_FRESHNESS -> "Checking error freshness…"
        AutoBuildState.READING_ERROR_LOGS       -> "Pulling error logs…"
        AutoBuildState.ATTACHING_FILES          -> "Attaching error logs to Claude…"
        AutoBuildState.SUBMITTING_PROMPT        -> "Submitting prompt…"
        AutoBuildState.BUILD_SUCCEEDED          -> "Build succeeded!"
        AutoBuildState.TIMEOUT_ERROR            -> "Timeout — retrying…"
        AutoBuildState.IDLE                     -> "Idle"
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/FileManagerModule.kt =====
package com.jarvismini.devtools.autobuild

import android.util.Log
import com.jarvismini.devtools.autobuild.models.ErrorFingerprint
import com.jarvismini.devtools.autobuild.models.ErrorLogBundle
import com.jarvismini.devtools.autobuild.models.LoopState
import java.io.File
import java.security.MessageDigest

/**
 * All file I/O for the AutoBuild loop.
 *
 * Shared storage layout (all under BASE_DIR):
 *
 *   /sdcard/ai-automation/
 *     ai-output.txt                  Claude code response → pushed by Termux to JarvisMini repo
 *     loop_state.json                Crash-recovery checkpoint
 *     last_error_fingerprint.json    SHA-256 + mtime of last processed error_summary.txt
 *     build_error_logs/
 *       error_summary.txt            Written by Apk.yml on failure, committed + pushed to main
 *       error_files.txt              Written by Apk.yml on failure, committed + pushed to main
 *
 * Termux pulls both files from the JarvisMini repo via `git pull` after each
 * failed Apk.yml run. clearBuildFlags() wipes them before a new build starts
 * but intentionally preserves last_error_fingerprint.json for the freshness check.
 */
class FileManagerModule {

    companion object {
        private const val TAG = "DevTools:FileManager"

        val BASE_DIR             = File("/sdcard/ai-automation")
        val LOG_DIR              = File(BASE_DIR, "build_error_logs")
        val AI_OUTPUT_FILE       = File(BASE_DIR, "ai-output.txt")
        val LOOP_STATE_FILE      = File(BASE_DIR, "loop_state.json")
        val FINGERPRINT_FILE     = File(BASE_DIR, "last_error_fingerprint.json")
        val ERROR_SUMMARY_FILE   = File(LOG_DIR,  "error_summary.txt")
        val ERROR_FILES_FILE     = File(LOG_DIR,  "error_files.txt")
    }

    // ── ai-output.txt ─────────────────────────────────────────────────────────

    /** Atomically write Claude's extracted code to ai-output.txt. */
    fun writeAiOutput(content: String) {
        BASE_DIR.mkdirs()
        val tmp = File(BASE_DIR, "ai-output.tmp")
        tmp.writeText(content)
        tmp.renameTo(AI_OUTPUT_FILE)
        Log.d(TAG, "ai-output.txt written (${content.length} chars)")
    }

    // ── Error log reads ───────────────────────────────────────────────────────

    /**
     * Reads error_summary.txt and error_files.txt from build_error_logs/.
     * These files are committed by Apk.yml on failure and pulled by Termux.
     * Returns null if either file is missing.
     */
    fun readErrorLogs(): ErrorLogBundle? {
        if (!ERROR_SUMMARY_FILE.exists() || !ERROR_FILES_FILE.exists()) {
            Log.w(TAG, "readErrorLogs: files not present in ${LOG_DIR.absolutePath}")
            return null
        }
        return ErrorLogBundle(
            errorFilesContent   = ERROR_FILES_FILE.readText(),
            errorSummaryContent = ERROR_SUMMARY_FILE.readText()
        )
    }

    /** True when error_summary.txt exists — Apk.yml only writes it on failure. */
    fun buildFailed(): Boolean = ERROR_SUMMARY_FILE.exists()

    // ── Build flag management ─────────────────────────────────────────────────

    /**
     * Clears error log files before a new build trigger.
     * Does NOT delete last_error_fingerprint.json — it must survive across
     * build iterations so CHECKING_ERROR_FRESHNESS can compare correctly.
     */
    fun clearBuildFlags() {
        LOG_DIR.listFiles()?.forEach { it.delete() }
        LOG_DIR.mkdirs()
        Log.d(TAG, "build_error_logs/ cleared (fingerprint preserved)")
    }

    /**
     * Deletes the crash-recovery checkpoint so the loop always starts fresh
     * from WAITING_FOR_RESPONSE on the next service connect, rather than
     * resuming from a stale mid-build state (e.g. WAITING_FOR_BUILD) that
     * would poll forever for a flag that will never arrive.
     *
     * Called by AutoBuildService.onServiceConnected().
     */
    fun clearCheckpoint() {
        if (LOOP_STATE_FILE.delete()) {
            Log.d(TAG, "loop_state.json cleared — loop will start fresh")
        }
        // Also clear the build_complete flag so pollForCompletion starts clean
        TermuxBridgeModule.COMPLETE_FLAG.delete()
    }

    // ── Error fingerprint ─────────────────────────────────────────────────────

    fun computeErrorFingerprint(iteration: Int): ErrorFingerprint {
        val mtime = if (ERROR_SUMMARY_FILE.exists()) ERROR_SUMMARY_FILE.lastModified() else 0L
        val bytes = runCatching { ERROR_SUMMARY_FILE.readBytes() }.getOrElse { ByteArray(0) }
        val hash  = MessageDigest.getInstance("SHA-256")
            .digest(bytes)
            .joinToString("") { "%02x".format(it) }
        return ErrorFingerprint(mtime, hash, iteration)
    }

    fun readErrorFingerprint(): ErrorFingerprint? {
        if (!FINGERPRINT_FILE.exists()) return null
        return ErrorFingerprint.fromJson(FINGERPRINT_FILE.readText())
    }

    fun saveErrorFingerprint(fp: ErrorFingerprint) {
        val tmp = File(BASE_DIR, "fingerprint.tmp")
        tmp.writeText(fp.toJson())
        tmp.renameTo(FINGERPRINT_FILE)
        Log.d(TAG, "Fingerprint saved iter=${fp.buildIteration} hash=${fp.contentHash.take(8)}…")
    }

    /**
     * Returns true when error_summary.txt is genuinely new compared to the
     * stored fingerprint (different mtime OR different SHA-256).
     * Always true on first ever failure (no stored fingerprint).
     */
    fun hasNewErrors(iteration: Int): Boolean {
        if (!ERROR_SUMMARY_FILE.exists()) return false
        val stored  = readErrorFingerprint() ?: return true   // first failure
        val current = computeErrorFingerprint(iteration)
        val isNew   = current.lastModifiedMs != stored.lastModifiedMs ||
                      current.contentHash    != stored.contentHash
        Log.d(TAG, "hasNewErrors=$isNew (stored=${stored.contentHash.take(8)}… current=${current.contentHash.take(8)}…)")
        return isNew
    }

    // ── Loop state ────────────────────────────────────────────────────────────

    fun saveState(state: LoopState) {
        runCatching {
            BASE_DIR.mkdirs()
            LOOP_STATE_FILE.writeText(state.toJson())
        }.onFailure { Log.e(TAG, "saveState failed", it) }
    }

    fun loadState(): LoopState? = runCatching {
        if (!LOOP_STATE_FILE.exists()) null
        else LoopState.fromJson(LOOP_STATE_FILE.readText())
    }.getOrNull()
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/ModeStore.kt =====
package com.jarvismini.devtools.autobuild

import android.content.Context
import com.jarvismini.devtools.autobuild.models.ExtractionMode

/**
 * Persists the user-selected ExtractionMode to SharedPreferences.
 * Readable from both MainActivity and the background service.
 */
object ModeStore {
    private const val PREFS = "devtools_prefs"
    private const val KEY   = "extraction_mode"

    fun save(context: Context, mode: ExtractionMode) {
        context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
            .edit().putString(KEY, mode.name).apply()
    }

    fun load(context: Context): ExtractionMode {
        val raw = context.getSharedPreferences(PREFS, Context.MODE_PRIVATE)
            .getString(KEY, ExtractionMode.CODE_BLOCK.name)
        return runCatching { ExtractionMode.valueOf(raw!!) }
            .getOrDefault(ExtractionMode.CODE_BLOCK)
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/OrchestrationController.kt =====
package com.jarvismini.devtools.autobuild

import android.content.Context
import android.util.Log
import com.jarvismini.devtools.autobuild.models.AutoBuildState
import com.jarvismini.devtools.autobuild.models.BuildResult
import com.jarvismini.devtools.autobuild.models.ErrorLogBundle
import com.jarvismini.devtools.autobuild.models.ExtractionMode
import com.jarvismini.devtools.autobuild.models.LoopState
import kotlinx.coroutines.delay

/**
 * State machine + main loop.
 *
 * EXTRACTING_CODE delegates to UIWatcherModule.extractAndWrite() which handles
 * all three modes. In every case the result is ai-output.txt on disk before
 * TRIGGERING_BUILD fires.
 */
class OrchestrationController(
    private val context: Context,
    private val uiWatcher: UIWatcherModule
) {
    companion object {
        private const val TAG = "DevTools:Orchestrator"

        const val LOOP_MAX_ITERATIONS   = 50
        const val MAX_RETRIES_PER_STATE = 3
        const val BETWEEN_ITER_DELAY_MS = 500L

        const val STALE_ERROR_PROMPT =
            "The build is still failing with the same errors as the previous attempt. " +
            "Please try a different approach or check for structural issues."

        const val FRESH_ERROR_PROMPT =
            "The build failed. The error logs are attached below. " +
            "Please analyze the errors and provide corrected code."
    }

    private val fm       = FileManagerModule()
    private val termux   = TermuxBridgeModule(context)
    private val notifier = BuildNotifier(context)

    private var retryCount  = 0
    private var errorBundle: ErrorLogBundle? = null

    @Volatile private var stopRequested = false

    fun requestStop() { stopRequested = true }

    suspend fun runLoop() {
        val checkpoint = fm.loadState()
        var state      = checkpoint?.state     ?: AutoBuildState.WAITING_FOR_RESPONSE
        var iteration  = checkpoint?.iteration ?: 0
        stopRequested  = false

        // Read mode once per loop start — persisted via ModeStore / spinner in MainActivity
        val mode = ModeStore.load(context)
        log("Loop started — state=$state iter=$iteration mode=$mode")
        notifier.update(iteration, state)

        while (iteration < LOOP_MAX_ITERATIONS && !stopRequested) {
            fm.saveState(LoopState(state, iteration))

            state = when (state) {

                AutoBuildState.IDLE ->
                    AutoBuildState.WAITING_FOR_RESPONSE

                AutoBuildState.WAITING_FOR_RESPONSE -> {
                    val done = uiWatcher.waitForResponseComplete()
                    if (done) AutoBuildState.EXTRACTING_CODE
                    else      timeout(state)
                }

                AutoBuildState.EXTRACTING_CODE -> {
                    val root = uiWatcher.service.rootInActiveWindow
                    // extractAndWrite handles all three modes internally.
                    // For DOWNLOADED_FILE it also coordinates the Termux snapshot
                    // and assemble steps before returning.
                    val ok = uiWatcher.extractAndWrite(root, mode, termux)
                    if (ok) {
                        log("Extraction OK (mode=$mode) — ai-output.txt ready")
                        AutoBuildState.TRIGGERING_BUILD
                    } else {
                        retry(state)
                    }
                }

                AutoBuildState.WRITING_OUTPUT ->
                    AutoBuildState.TRIGGERING_BUILD

                AutoBuildState.TRIGGERING_BUILD -> {
                    log("Triggering build (iteration=$iteration) via Termux…")
                    termux.triggerBuild()
                    retryCount = 0
                    AutoBuildState.WAITING_FOR_BUILD
                }

                AutoBuildState.WAITING_FOR_BUILD -> {
                    log("Polling for Apk.yml completion…")
                    when (termux.pollForCompletion()) {
                        BuildResult.SUCCESS -> AutoBuildState.BUILD_SUCCEEDED
                        BuildResult.FAILURE -> AutoBuildState.CHECKING_ERROR_FRESHNESS
                        BuildResult.TIMEOUT -> timeout(state)
                    }
                }

                AutoBuildState.BUILD_SUCCEEDED -> {
                    log("✅ Build succeeded after $iteration iteration(s)")
                    notifier.success(iteration)
                    return
                }

                AutoBuildState.CHECKING_ERROR_FRESHNESS -> {
                    if (fm.hasNewErrors(iteration)) {
                        log("New error logs detected — reading logs")
                        AutoBuildState.READING_ERROR_LOGS
                    } else {
                        log("Error logs unchanged — sending nudge prompt")
                        uiWatcher.fillPromptField(STALE_ERROR_PROMPT)
                        iteration++
                        AutoBuildState.SUBMITTING_PROMPT
                    }
                }

                AutoBuildState.READING_ERROR_LOGS -> {
                    val bundle = fm.readErrorLogs()
                    if (bundle != null) {
                        fm.saveErrorFingerprint(fm.computeErrorFingerprint(iteration))
                        errorBundle = bundle
                        log("Error logs read (${bundle.errorSummaryContent.length} chars)")
                        AutoBuildState.ATTACHING_FILES
                    } else {
                        log("Error logs missing after FAILURE — retrying", isError = true)
                        timeout(state)
                    }
                }

                AutoBuildState.ATTACHING_FILES -> {
                    val ok = attachErrorFiles()
                    if (ok) { iteration++; AutoBuildState.SUBMITTING_PROMPT }
                    else    retry(state)
                }

                AutoBuildState.SUBMITTING_PROMPT -> {
                    uiWatcher.tapSendButton()
                    delay(UIWatcherModule.POST_TAP_DELAY_MS)
                    AutoBuildState.WAITING_FOR_RESPONSE
                }

                AutoBuildState.TIMEOUT_ERROR -> {
                    val backoff = 1_000L * (1 shl minOf(retryCount, 3))
                    log("Timeout recovery — waiting ${backoff}ms (retry=$retryCount)", isError = true)
                    delay(backoff)
                    if (++retryCount > MAX_RETRIES_PER_STATE) {
                        notifier.error("Too many retries — stopped at $state")
                        return
                    }
                    AutoBuildState.WAITING_FOR_RESPONSE
                }
            }

            AutoBuildService.currentState     = state
            AutoBuildService.currentIteration = iteration
            notifier.update(iteration, state)
            AutoBuildService.onStatusUpdate?.invoke(iteration, state)
            delay(BETWEEN_ITER_DELAY_MS)
        }

        if (stopRequested) log("Loop stopped by user request")
        else log("Max iterations ($LOOP_MAX_ITERATIONS) reached — stopping", isError = true)
        notifier.error(if (stopRequested) "Stopped by user" else "Max iterations reached")
    }

    private suspend fun attachErrorFiles(): Boolean {
        if (!uiWatcher.tapAddFilesButton()) {
            log("tapAddFilesButton failed (1)", isError = true); return false
        }
        if (!uiWatcher.selectFileInPicker(FileManagerModule.ERROR_FILES_FILE.name)) {
            log("selectFileInPicker(error_files.txt) failed", isError = true); return false
        }
        delay(UIWatcherModule.POST_TAP_DELAY_MS)

        if (!uiWatcher.tapAddFilesButton()) {
            log("tapAddFilesButton failed (2)", isError = true); return false
        }
        if (!uiWatcher.selectFileInPicker(FileManagerModule.ERROR_SUMMARY_FILE.name)) {
            log("selectFileInPicker(error_summary.txt) failed", isError = true); return false
        }
        delay(UIWatcherModule.POST_TAP_DELAY_MS)

        uiWatcher.fillPromptField(FRESH_ERROR_PROMPT)
        log("Both error files attached, prompt filled")
        return true
    }

    private fun timeout(state: AutoBuildState): AutoBuildState {
        log("Timeout in $state", isError = true)
        return AutoBuildState.TIMEOUT_ERROR
    }

    private fun retry(state: AutoBuildState): AutoBuildState {
        return if (++retryCount <= MAX_RETRIES_PER_STATE) {
            log("Retrying $state (attempt $retryCount)")
            state
        } else {
            log("Max retries exceeded for $state", isError = true)
            AutoBuildState.TIMEOUT_ERROR
        }
    }

    private fun log(msg: String, isError: Boolean = false) {
        if (isError) Log.e(TAG, msg) else Log.d(TAG, msg)
        AutoBuildService.onLogLine?.invoke(msg, isError)
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/TermuxBridgeModule.kt =====
package com.jarvismini.devtools.autobuild

import android.content.Context
import android.content.Intent
import android.util.Log
import com.jarvismini.devtools.autobuild.models.BuildResult
import kotlinx.coroutines.delay
import java.io.File

/**
 * Drives the GitHub Actions pipeline via Termux RUN_COMMAND broadcasts.
 *
 * Three script modes (all run build_runner.sh with different args):
 *
 *   (no args)              — normal build: copy ai-output.txt → git push → watch pipeline
 *   --snapshot             — record files currently in /sdcard/Download/ before tapping
 *   --assemble-downloads   — detect new files in /sdcard/Download/, assemble ai-output.txt
 *                            in //===== FILE: filename ===== format, write assembled flag
 *
 * Requires:
 *   - Termux from F-Droid (Play Store build lacks RUN_COMMAND permission)
 *   - "Allow External Apps" enabled in Termux → Settings
 *   - gh CLI authenticated: gh auth login
 *   - git remote with push access configured in ~/jarvis/
 */
class TermuxBridgeModule(private val context: Context) {

    companion object {
        private const val TAG = "DevTools:TermuxBridge"

        private const val TERMUX_PKG    = "com.termux"
        private const val TERMUX_ACTION = "com.termux.RUN_COMMAND"
        private const val TERMUX_BASH   = "/data/data/com.termux/files/usr/bin/bash"
        private const val TERMUX_HOME   = "/data/data/com.termux/files/home"
        private const val RUNNER_SCRIPT = "/sdcard/ai-automation/scripts/build_runner.sh"

        const val POLL_INTERVAL_MS = 12_000L   // 12s between completion polls
        const val BUILD_TIMEOUT_MS = 720_000L  // 12 min max

        val COMPLETE_FLAG = File("/sdcard/ai-automation/build_complete.flag")
    }

    /**
     * Fires build_runner.sh with the given arguments via Termux broadcast.
     * Pass no args (empty) for the normal build push.
     * Pass "--snapshot" or "--assemble-downloads" for download mode helpers.
     */
    fun runScript(vararg args: String) {
        val scriptArgs = if (args.isEmpty()) {
            arrayOf(RUNNER_SCRIPT)
        } else {
            arrayOf(RUNNER_SCRIPT, *args)
        }

        val intent = Intent(TERMUX_ACTION).apply {
            setPackage(TERMUX_PKG)
            putExtra("com.termux.RUN_COMMAND_PATH",       TERMUX_BASH)
            putExtra("com.termux.RUN_COMMAND_ARGUMENTS",  scriptArgs)
            putExtra("com.termux.RUN_COMMAND_WORKDIR",    TERMUX_HOME)
            putExtra("com.termux.RUN_COMMAND_BACKGROUND", true)
        }
        runCatching { context.sendBroadcast(intent) }
            .onSuccess { Log.d(TAG, "Termux broadcast sent: build_runner.sh ${args.joinToString(" ")}") }
            .onFailure { Log.e(TAG, "Termux broadcast failed", it) }
    }

    /**
     * Normal build trigger: clears flags, fires build_runner.sh with no args.
     */
    fun triggerBuild() {
        COMPLETE_FLAG.delete()
        FileManagerModule().clearBuildFlags()
        runScript()  // no args = normal push mode
    }

    /**
     * Polls every POLL_INTERVAL_MS for build_complete.flag.
     * build_runner.sh writes this after git pull completes (success or failure).
     */
    suspend fun pollForCompletion(timeoutMs: Long = BUILD_TIMEOUT_MS): BuildResult {
        val deadline = System.currentTimeMillis() + timeoutMs
        val fm = FileManagerModule()

        while (System.currentTimeMillis() < deadline) {
            delay(POLL_INTERVAL_MS)
            if (COMPLETE_FLAG.exists()) {
                Log.d(TAG, "build_complete.flag detected")
                return if (fm.buildFailed()) {
                    Log.d(TAG, "error_summary.txt present → FAILURE")
                    BuildResult.FAILURE
                } else {
                    Log.d(TAG, "No error_summary.txt → SUCCESS")
                    BuildResult.SUCCESS
                }
            }
            val remaining = (deadline - System.currentTimeMillis()) / 1000
            Log.d(TAG, "Waiting for build… ${remaining}s remaining")
        }

        Log.w(TAG, "Build poll timed out after ${timeoutMs / 1000}s")
        return BuildResult.TIMEOUT
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/UIWatcherModule.kt =====
package com.jarvismini.devtools.autobuild

import android.accessibilityservice.AccessibilityService
import android.os.Bundle
import android.util.Log
import android.view.accessibility.AccessibilityNodeInfo
import com.jarvismini.devtools.autobuild.models.ExtractionMode
import kotlinx.coroutines.delay
import java.io.File

/**
 * All UI interaction with the Claude Android app.
 *
 * Three extraction modes:
 *
 *   CODE_BLOCK
 *     Walks node tree for HorizontalScrollView → TextView children.
 *     Joins all blocks and writes /sdcard/ai-automation/ai-output.txt directly.
 *
 *   DOWNLOADED_FILE
 *     1. Fires Termux: build_runner.sh --snapshot
 *        (records what files already exist in /sdcard/Download/)
 *     2. Finds and taps ALL visible download buttons in Claude's UI sequentially.
 *     3. Fires Termux: build_runner.sh --assemble-downloads
 *        (Termux detects new files, assembles ai-output.txt in file-header format)
 *     4. Polls for /sdcard/ai-automation/downloads_assembled.flag.
 *     Returns true once flag exists — OrchestrationController then moves to TRIGGERING_BUILD.
 *     NOTE: actual file reading / ai-output.txt assembly is entirely done by Termux,
 *     not by this app. No clipboard. No size limits.
 *
 *   PLAIN_TEXT
 *     Grabs the largest TextView in the window, writes ai-output.txt directly.
 *
 * Node content-desc values below are PLACEHOLDERS pending uiautomator dump verification.
 * After dumping the real tree, update DOWNLOAD_BUTTON_DESCS with confirmed values.
 */
class UIWatcherModule(val service: AccessibilityService) {

    companion object {
        private const val TAG = "DevTools:UIWatcher"

        const val CLAUDE_PKG           = "com.anthropic.claude"
        const val STABILITY_WINDOW_MS  = 2_500L
        const val RESPONSE_TIMEOUT_MS  = 120_000L
        const val POST_TAP_DELAY_MS    = 900L
        const val FILE_ATTACH_DELAY_MS = 1_600L

        // How long to wait for Termux to finish assembling ai-output.txt
        const val ASSEMBLY_TIMEOUT_MS  = 60_000L
        const val ASSEMBLY_POLL_MS     = 1_000L

        val STREAMING_INDICATORS = setOf("●", "Thinking…", "Thinking...", "▌")

        const val ADD_TO_CHAT_DESC = "Add to chat"
        const val SEND_DESC        = "Send"

        // ── PLACEHOLDERS — update after uiautomator dump ──────────────────────
        // These are the content-desc values tried IN ORDER when looking for
        // download buttons. The first match per node wins.
        val DOWNLOAD_BUTTON_DESCS = listOf(
            "Download file",
            "Download",
            "download"
        )
        // File extensions that count as code output from Claude.
        // Any new file in /sdcard/Download/ matching these is picked up by Termux.
        val CODE_EXTENSIONS = setOf(
            "kt", "java", "py", "txt", "xml", "json", "gradle",
            "kts", "sh", "cpp", "c", "h", "ts", "js", "md"
        )
        // ─────────────────────────────────────────────────────────────────────

        val ASSEMBLED_FLAG = File("/sdcard/ai-automation/downloads_assembled.flag")
    }

    @Volatile var lastClaudeEventMs: Long = 0L

    fun onAccessibilityEvent(packageName: String?) {
        if (packageName == CLAUDE_PKG) lastClaudeEventMs = System.currentTimeMillis()
    }

    // ── Response completion ───────────────────────────────────────────────────

    suspend fun waitForResponseComplete(timeoutMs: Long = RESPONSE_TIMEOUT_MS): Boolean {
        val deadline = System.currentTimeMillis() + timeoutMs
        delay(1_500L)
        while (System.currentTimeMillis() < deadline) {
            val elapsed = System.currentTimeMillis() - lastClaudeEventMs
            if (elapsed >= STABILITY_WINDOW_MS && !isStreamingIndicatorVisible()) {
                Log.d(TAG, "Response stable for ${elapsed}ms — complete")
                return true
            }
            delay(500L)
        }
        Log.w(TAG, "waitForResponseComplete timed out")
        return false
    }

    private fun isStreamingIndicatorVisible(): Boolean {
        val root = service.rootInActiveWindow ?: return false
        return findNodeByText(root, STREAMING_INDICATORS) != null
    }

    // ── Unified extraction ────────────────────────────────────────────────────

    /**
     * Extracts code according to [mode] and ensures ai-output.txt is ready on disk.
     * Returns true on success, false if extraction failed (caller will retry).
     */
    suspend fun extractAndWrite(
        root: AccessibilityNodeInfo?,
        mode: ExtractionMode,
        termux: TermuxBridgeModule
    ): Boolean = when (mode) {

        ExtractionMode.CODE_BLOCK -> {
            val blocks = extractCodeBlocks(root)
            if (blocks.isEmpty()) {
                Log.w(TAG, "CODE_BLOCK: no blocks found")
                false
            } else {
                writeAiOutput(blocks.joinToString("\n\n// ===== next block =====\n\n"))
                true
            }
        }

        ExtractionMode.DOWNLOADED_FILE -> {
            downloadViaTermux(termux)
        }

        ExtractionMode.PLAIN_TEXT -> {
            val text = largestTextViewText(root)
            if (text.isNullOrBlank()) {
                Log.w(TAG, "PLAIN_TEXT: no text found")
                false
            } else {
                writeAiOutput(text)
                true
            }
        }
    }

    // ── CODE_BLOCK extraction ─────────────────────────────────────────────────

    private fun extractCodeBlocks(root: AccessibilityNodeInfo?): List<String> {
        root ?: return emptyList()
        val blocks = mutableListOf<String>()
        collectCodeBlocks(root, blocks)
        if (blocks.isEmpty()) {
            Log.w(TAG, "No HorizontalScrollView blocks found, trying largest TextView")
            largestTextViewText(root)?.takeIf { it.isNotBlank() }?.let { blocks.add(it) }
        }
        Log.d(TAG, "Extracted ${blocks.size} code block(s)")
        return blocks
    }

    private fun collectCodeBlocks(node: AccessibilityNodeInfo, out: MutableList<String>) {
        if (node.className?.toString() == "android.widget.HorizontalScrollView") {
            for (i in 0 until node.childCount) {
                val child = node.getChild(i) ?: continue
                val text = child.text?.toString()
                if (!text.isNullOrBlank()) {
                    out.add(text)
                    Log.d(TAG, "Code block (${text.length} chars): ${text.take(60)}…")
                }
            }
            return
        }
        for (i in 0 until node.childCount) {
            collectCodeBlocks(node.getChild(i) ?: continue, out)
        }
    }

    private fun largestTextViewText(root: AccessibilityNodeInfo?): String? {
        var best: String? = null
        fun traverse(n: AccessibilityNodeInfo?) {
            n ?: return
            if (n.className?.toString()?.endsWith("TextView") == true) {
                val t = n.text?.toString() ?: ""
                if (t.length > (best?.length ?: 0)) best = t
            }
            for (i in 0 until n.childCount) traverse(n.getChild(i))
        }
        traverse(root)
        return best
    }

    // ── DOWNLOADED_FILE extraction ────────────────────────────────────────────

    /**
     * Full sequence for DOWNLOADED_FILE mode:
     *   1. Termux snapshots /sdcard/Download/ (so it knows what was there before)
     *   2. App taps every visible download button in Claude's UI
     *   3. Termux assembles ai-output.txt from the new files
     *   4. App waits for downloads_assembled.flag
     */
    private suspend fun downloadViaTermux(termux: TermuxBridgeModule): Boolean {
        // Step 1 — snapshot before tapping anything
        ASSEMBLED_FLAG.delete()
        termux.runScript("--snapshot")
        delay(1_500L)   // give Termux a moment to write the snapshot

        // Step 2 — tap all visible download buttons
        val count = tapAllDownloadButtons()
        if (count == 0) {
            Log.w(TAG, "DOWNLOADED_FILE: no download buttons found in current window")
            return false
        }
        Log.d(TAG, "Tapped $count download button(s)")

        // Step 3 — tell Termux to assemble ai-output.txt
        delay(2_000L)   // brief wait so downloads have a moment to start
        termux.runScript("--assemble-downloads")

        // Step 4 — poll for assembled flag
        val deadline = System.currentTimeMillis() + ASSEMBLY_TIMEOUT_MS
        while (System.currentTimeMillis() < deadline) {
            delay(ASSEMBLY_POLL_MS)
            if (ASSEMBLED_FLAG.exists()) {
                Log.d(TAG, "downloads_assembled.flag detected — ai-output.txt ready")
                return true
            }
        }

        Log.w(TAG, "DOWNLOADED_FILE: assembly timed out after ${ASSEMBLY_TIMEOUT_MS / 1000}s")
        return false
    }

    /**
     * Walks the entire node tree and taps every download button found.
     * Collects all matching nodes first, then taps them sequentially with
     * a delay between each so Claude has time to process each download.
     * Returns the number of buttons tapped.
     */
    private suspend fun tapAllDownloadButtons(): Int {
        val root = service.rootInActiveWindow ?: return 0
        val nodes = mutableListOf<AccessibilityNodeInfo>()
        collectDownloadNodes(root, nodes)

        if (nodes.isEmpty()) return 0

        Log.d(TAG, "Found ${nodes.size} download node(s)")
        var tapped = 0
        for (node in nodes) {
            val clickable = resolveClickable(node)
            if (clickable != null) {
                val ok = clickable.performAction(AccessibilityNodeInfo.ACTION_CLICK)
                if (ok) {
                    tapped++
                    Log.d(TAG, "Tapped download button #$tapped")
                    delay(POST_TAP_DELAY_MS)
                }
            }
        }
        return tapped
    }

    /**
     * Recursively collects nodes that look like download buttons.
     * Tries content-desc match against DOWNLOAD_BUTTON_DESCS.
     * Also catches nodes whose content-desc ends with a known code extension
     * (e.g. Claude sometimes uses the filename "MainActivity.kt" as the desc).
     */
    private fun collectDownloadNodes(
        node: AccessibilityNodeInfo,
        out: MutableList<AccessibilityNodeInfo>
    ) {
        val desc = node.contentDescription?.toString() ?: ""
        val isDownloadByDesc = DOWNLOAD_BUTTON_DESCS.any { d ->
            desc.equals(d, ignoreCase = true)
        }
        val isDownloadByExt = CODE_EXTENSIONS.any { ext ->
            desc.endsWith(".$ext", ignoreCase = true)
        }
        if (isDownloadByDesc || isDownloadByExt) {
            out.add(node)
            return  // don't recurse into this node's children
        }
        for (i in 0 until node.childCount) {
            collectDownloadNodes(node.getChild(i) ?: continue, out)
        }
    }

    /**
     * Given a node (which may be the icon/label rather than the hit-area),
     * walks UP the tree to find the nearest clickable ancestor.
     * Falls back to the node itself if it is clickable.
     */
    private fun resolveClickable(node: AccessibilityNodeInfo): AccessibilityNodeInfo? {
        if (node.isClickable) return node
        var current: AccessibilityNodeInfo? = node.parent
        while (current != null) {
            if (current.isClickable) return current
            current = current.parent
        }
        return null
    }

    // ── ai-output.txt write ───────────────────────────────────────────────────

    private fun writeAiOutput(content: String) {
        val dir = File("/sdcard/ai-automation")
        dir.mkdirs()
        val tmp = File(dir, "ai-output.tmp")
        tmp.writeText(content)
        tmp.renameTo(File(dir, "ai-output.txt"))
        Log.d(TAG, "ai-output.txt written (${content.length} chars)")
    }

    // ── Prompt field ──────────────────────────────────────────────────────────

    fun fillPromptField(text: String): Boolean {
        val root  = service.rootInActiveWindow ?: return false
        val input = findEditText(root) ?: run {
            Log.w(TAG, "fillPromptField: EditText not found")
            return false
        }
        val args = Bundle().apply {
            putString(AccessibilityNodeInfo.ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, text)
        }
        return input.performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, args)
    }

    // ── Error log file attachment ─────────────────────────────────────────────

    suspend fun tapAddFilesButton(): Boolean {
        val root = service.rootInActiveWindow ?: return false
        val node = findClickableParentByDesc(root, ADD_TO_CHAT_DESC) ?: run {
            Log.w(TAG, "Add to chat button not found")
            return false
        }
        return node.performAction(AccessibilityNodeInfo.ACTION_CLICK)
            .also { if (it) delay(FILE_ATTACH_DELAY_MS) }
    }

    suspend fun selectFileInPicker(fileName: String): Boolean {
        delay(POST_TAP_DELAY_MS)
        val root = service.rootInActiveWindow ?: return false
        val node = findNodeByText(root, setOf(fileName)) ?: run {
            Log.w(TAG, "File '$fileName' not visible in picker")
            return false
        }
        val clicked = node.performAction(AccessibilityNodeInfo.ACTION_CLICK)
        if (clicked) {
            delay(POST_TAP_DELAY_MS)
            confirmPickerSelection()
        }
        return clicked
    }

    private suspend fun confirmPickerSelection() {
        val root = service.rootInActiveWindow ?: return
        findNodeByText(root, setOf("Select", "Open", "Done", "OK"))
            ?.performAction(AccessibilityNodeInfo.ACTION_CLICK)
        delay(POST_TAP_DELAY_MS)
    }

    suspend fun tapSendButton(): Boolean {
        val root = service.rootInActiveWindow ?: return false
        val node = findClickableParentByDesc(root, SEND_DESC) ?: run {
            Log.w(TAG, "Send button not found")
            return false
        }
        return node.performAction(AccessibilityNodeInfo.ACTION_CLICK)
            .also { if (it) delay(POST_TAP_DELAY_MS) }
    }

    // ── Node search helpers ───────────────────────────────────────────────────

    private fun findClickableParentByDesc(
        root: AccessibilityNodeInfo,
        desc: String
    ): AccessibilityNodeInfo? {
        val target = findNodeByDesc(root, desc) ?: return null
        return resolveClickable(target)
    }

    private fun findNodeByDesc(
        root: AccessibilityNodeInfo,
        desc: String
    ): AccessibilityNodeInfo? {
        if (root.contentDescription?.toString().equals(desc, ignoreCase = true)) return root
        for (i in 0 until root.childCount) {
            findNodeByDesc(root.getChild(i) ?: continue, desc)?.let { return it }
        }
        return null
    }

    private fun findNodeByText(
        root: AccessibilityNodeInfo,
        targets: Set<String>
    ): AccessibilityNodeInfo? {
        val text = root.text?.toString()?.trim() ?: ""
        if (targets.any { text.contains(it, ignoreCase = true) }) return root
        for (i in 0 until root.childCount) {
            findNodeByText(root.getChild(i) ?: continue, targets)?.let { return it }
        }
        return null
    }

    private fun findEditText(root: AccessibilityNodeInfo): AccessibilityNodeInfo? {
        if (root.className?.toString()?.endsWith("EditText") == true && root.isEditable) return root
        for (i in 0 until root.childCount) {
            findEditText(root.getChild(i) ?: continue)?.let { return it }
        }
        return null
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/models/AutoBuildState.kt =====
package com.jarvismini.devtools.autobuild.models

enum class AutoBuildState {
    IDLE,
    WAITING_FOR_RESPONSE,
    EXTRACTING_CODE,
    WRITING_OUTPUT,
    TRIGGERING_BUILD,
    WAITING_FOR_BUILD,
    CHECKING_ERROR_FRESHNESS,
    READING_ERROR_LOGS,
    ATTACHING_FILES,
    SUBMITTING_PROMPT,
    BUILD_SUCCEEDED,
    TIMEOUT_ERROR
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/models/BuildResult.kt =====
package com.jarvismini.devtools.autobuild.models

enum class BuildResult {
    SUCCESS,
    FAILURE,
    TIMEOUT
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/models/ErrorFingerprint.kt =====
package com.jarvismini.devtools.autobuild.models

import org.json.JSONObject

/**
 * Fingerprint of the last-processed error_summary.txt.
 * Used by FileManagerModule.hasNewErrors() to avoid reprocessing
 * identical logs when the build fails with the same errors twice in a row.
 *
 * Stored at: /sdcard/ai-automation/last_error_fingerprint.json
 */
data class ErrorFingerprint(
    val lastModifiedMs: Long,
    val contentHash: String,      // SHA-256 hex of error_summary.txt bytes
    val buildIteration: Int
) {
    fun toJson(): String = JSONObject()
        .put("lastModifiedMs", lastModifiedMs)
        .put("contentHash", contentHash)
        .put("buildIteration", buildIteration)
        .toString()

    companion object {
        fun fromJson(json: String): ErrorFingerprint? = runCatching {
            JSONObject(json).let {
                ErrorFingerprint(
                    lastModifiedMs  = it.getLong("lastModifiedMs"),
                    contentHash     = it.getString("contentHash"),
                    buildIteration  = it.getInt("buildIteration")
                )
            }
        }.getOrNull()
    }
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/models/ErrorLogBundle.kt =====
package com.jarvismini.devtools.autobuild.models

/**
 * Snapshot of error_summary.txt and error_files.txt read from
 * /sdcard/ai-automation/build_error_logs/ after Apk.yml commits them to main
 * and Termux pulls them down via git pull.
 */
data class ErrorLogBundle(
    val errorFilesContent: String,
    val errorSummaryContent: String,
    val capturedAtMs: Long = System.currentTimeMillis()
)


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/models/ExtractionMode.kt =====
package com.jarvismini.devtools.autobuild.models

/**
 * How the app extracts code from Claude's response.
 *
 * CODE_BLOCK      — Claude typed code inside a code fence in chat.
 *                   Identified by HorizontalScrollView in the node tree.
 *                   App writes ai-output.txt directly.
 *
 * DOWNLOADED_FILE — Claude attached downloadable file(s).
 *                   App taps every visible download button.
 *                   Termux assembles ai-output.txt from new files in /sdcard/Download/.
 *
 * PLAIN_TEXT      — Claude pasted raw code with no code fence.
 *                   App grabs largest TextView, writes ai-output.txt directly.
 */
enum class ExtractionMode {
    CODE_BLOCK,
    DOWNLOADED_FILE,
    PLAIN_TEXT
}


//===== FILE: app/src/main/kotlin/com/jarvismini/devtools/autobuild/models/LoopState.kt =====
package com.jarvismini.devtools.autobuild.models

import org.json.JSONObject

/**
 * Persisted to /sdcard/ai-automation/loop_state.json after every state
 * transition so the loop can resume from the last checkpoint if the service
 * is killed and restarted by Android.
 */
data class LoopState(
    val state: AutoBuildState,
    val iteration: Int,
    val lastUpdatedMs: Long = System.currentTimeMillis()
) {
    fun toJson(): String = JSONObject()
        .put("state", state.name)
        .put("iteration", iteration)
        .put("lastUpdatedMs", lastUpdatedMs)
        .toString()

    companion object {
        fun fromJson(json: String): LoopState? = runCatching {
            JSONObject(json).let {
                LoopState(
                    state         = AutoBuildState.valueOf(it.getString("state")),
                    iteration     = it.getInt("iteration"),
                    lastUpdatedMs = it.getLong("lastUpdatedMs")
                )
            }
        }.getOrNull()
    }
}


//===== FILE: app/src/main/res/drawable/circle_dot.xml =====
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <solid android:color="@color/grey_idle" />
</shape>


//===== FILE: app/src/main/res/layout/activity_main.xml =====
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="24dp"
    android:background="?android:attr/colorBackground">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="AutoBuild Loop"
        android:textSize="22sp"
        android:textStyle="bold"
        android:textColor="?attr/colorOnBackground"
        android:paddingBottom="8dp" />

    <!-- Accessibility service hint -->
    <TextView
        android:id="@+id/tvAccessibilityHint"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="⚠ AutoBuild Service not enabled"
        android:textSize="13sp"
        android:textColor="@color/red_error"
        android:paddingBottom="8dp"
        android:visibility="gone" />

    <!-- Extraction mode label -->
    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Claude output mode:"
        android:textSize="12sp"
        android:textColor="?attr/colorOnBackground"
        android:paddingBottom="2dp" />

    <!-- Mode spinner -->
    <Spinner
        android:id="@+id/spinnerMode"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingBottom="12dp" />

    <!-- Status row -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical"
        android:paddingBottom="12dp">

        <View
            android:id="@+id/statusDot"
            android:layout_width="14dp"
            android:layout_height="14dp"
            android:background="@drawable/circle_dot"
            android:backgroundTint="@color/grey_idle" />

        <TextView
            android:id="@+id/tvStatus"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="@string/status_idle"
            android:textSize="14sp"
            android:textColor="?attr/colorOnBackground"
            android:paddingStart="10dp" />

        <TextView
            android:id="@+id/tvIteration"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Iter: 0"
            android:textSize="13sp"
            android:textColor="?attr/colorOnBackground" />

    </LinearLayout>

    <!-- Scrollable log -->
    <ScrollView
        android:id="@+id/scrollLog"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:background="#1A000000"
        android:padding="8dp">

        <TextView
            android:id="@+id/tvLog"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:fontFamily="monospace"
            android:textSize="11sp"
            android:textColor="?attr/colorOnBackground"
            android:lineSpacingMultiplier="1.3" />

    </ScrollView>

    <!-- Start / Stop -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:paddingTop="16dp"
        android:gravity="center">

        <Button
            android:id="@+id/btnStart"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginEnd="8dp"
            android:text="@string/btn_start" />

        <Button
            android:id="@+id/btnStop"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:layout_marginStart="8dp"
            android:text="@string/btn_stop"
            android:enabled="false" />

    </LinearLayout>

    <Button
        android:id="@+id/btnAccessibility"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="8dp"
        android:text="@string/open_accessibility"
        style="@style/Widget.Material3.Button.OutlinedButton" />

</LinearLayout>


//===== FILE: app/src/main/res/values/colors.xml =====
<resources>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="green_success">#FF4CAF50</color>
    <color name="red_error">#FFF44336</color>
    <color name="yellow_waiting">#FFFFC107</color>
    <color name="grey_idle">#FF9E9E9E</color>
</resources>


//===== FILE: app/src/main/res/values/strings.xml =====
<resources>
    <string name="app_name">DevTools</string>
    <string name="autobuild_service_desc">Reads Claude code responses and drives the CI build loop automatically.</string>
    <string name="btn_start">Start AutoBuild</string>
    <string name="btn_stop">Stop AutoBuild</string>
    <string name="status_idle">Idle — enable service in Accessibility Settings</string>
    <string name="status_running">Running…</string>
    <string name="open_accessibility">Open Accessibility Settings</string>
</resources>


//===== FILE: app/src/main/res/values/themes.xml =====
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.DevTools" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="colorPrimary">#FF1565C0</item>
        <item name="colorPrimaryVariant">#FF003C8F</item>
        <item name="colorOnPrimary">@color/white</item>
        <item name="colorSecondary">#FF00B0FF</item>
        <item name="colorOnSecondary">@color/black</item>
        <item name="android:statusBarColor">?attr/colorPrimaryVariant</item>
    </style>
</resources>


//===== FILE: app/src/main/res/xml/autobuild_accessibility_config.xml =====
<accessibility-service
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:accessibilityEventTypes="
        typeWindowStateChanged
        | typeWindowContentChanged
        | typeViewClicked
        | typeViewFocused"
    android:accessibilityFeedbackType="feedbackGeneric"
    android:accessibilityFlags="
        flagReportViewIds
        | flagRetrieveInteractiveWindows
        | flagRequestEnhancedWebAccessibility"
    android:canPerformGestures="true"
    android:canRetrieveWindowContent="true"
    android:packageNames="com.anthropic.claude"
    android:notificationTimeout="100"
    android:description="@string/autobuild_service_desc" />


//===== FILE: gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.4-all.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


//===== FILE: .github/workflows/Ai-codegen.yml =====
name: AI Code Generator

on:
  workflow_dispatch:
  push:
    paths:
      - ai-output.txt

permissions:
  contents: write

jobs:
  generate:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Run AI Code Generator
        run: |
          python ai-code.py ai-output.txt
          


//===== FILE: .github/workflows/Apk.yml =====
name: Build APK

on:
  workflow_run:
    workflows: ["Extract Repo Source to TXT"]
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-apk:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          submodules: recursive
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17

      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: gradle-${{ runner.os }}-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
          restore-keys: gradle-${{ runner.os }}-

      # ---------------- BUILD (never hard-fails) ----------------
      - name: Build Debug APK and capture log
        id: gradle_build
        continue-on-error: true
        run: |
          chmod +x ./gradlew
          mkdir -p build_error_logs
          ./gradlew assembleDebug --no-daemon --stacktrace --info \
            2>&1 | tee build_error_logs/build_output.txt
          EXIT_CODE=${PIPESTATUS[0]}
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT

      # ---------------- APK UPLOAD ----------------
      - name: Upload Debug APK
        if: steps.gradle_build.outputs.exit_code == '0'
        uses: actions/upload-artifact@v4
        with:
          name: jarvis-debug-apk
          path: app/build/outputs/apk/debug/app-debug.apk

      # ---------------- ENHANCED ERROR EXTRACTION ----------------
      - name: Extract errors (enhanced for native builds)
        if: steps.gradle_build.outputs.exit_code != '0'
        run: |
          mkdir -p build_error_logs

          {
            echo "==== GRADLE BUILD ERROR REPORT ===="
            echo
            echo "-- CMAKE CONFIGURATION ERRORS --"
            grep -A 5 "CMake Error" build_error_logs/build_output.txt || echo "No CMake errors"
            echo
            echo "-- NINJA BUILD ERRORS --"
            grep -B 3 -A 3 "ninja: build stopped" build_error_logs/build_output.txt || echo "No ninja errors"
            echo
            echo "-- C++ COMPILATION ERRORS --"
            grep -E "error: |undefined reference|fatal error:" build_error_logs/build_output.txt | head -50 || echo "No C++ errors"
            echo
            echo "-- MISSING HEADERS/LIBRARIES --"
            grep -E "No such file|cannot find|ld returned" build_error_logs/build_output.txt || echo "No missing deps"
            echo
            echo "-- KOTLIN/JAVA ERRORS --"
            grep -E "\.kt:[0-9]+:[0-9]+ error|\.java:[0-9]+: error|^e: " build_error_logs/build_output.txt || echo "No Kotlin/Java errors"
            echo
            echo "-- XML RESOURCE ERRORS --"
            grep -E "\.xml:[0-9]+:" build_error_logs/build_output.txt || echo "No XML errors"
            echo
            echo "-- BUILD TASK FAILURES --"
            grep -E "BUILD FAILED|FAILURE: Build failed|Task.*FAILED" build_error_logs/build_output.txt || echo "No task failures"
            echo
            echo "-- EXCEPTION STACK TRACES --"
            grep -A 10 "Exception" build_error_logs/build_output.txt | head -100 || echo "No exceptions"
            echo
            echo "-- NATIVE BUILD LOG (last 100 lines) --"
            grep -E "(Building CXX|Linking CXX|CMake|ninja)" build_error_logs/build_output.txt | tail -100 || echo "No native build log"
          } > build_error_logs/error_summary.txt

          echo "==== ERROR SUMMARY ===="
          cat build_error_logs/error_summary.txt

          # Save tail of full log
          tail -1000 build_error_logs/build_output.txt > build_error_logs/build_tail.txt

      # ---------------- EXTRACT ERROR SOURCE FILES WITH PYTHON (FIXED PATH HANDLING) ----------------
      - name: Extract source code of error files with highlighted error lines
        if: steps.gradle_build.outputs.exit_code != '0'
        run: |
          python3 << 'PYTHON_SCRIPT'
          import re
          import os
          from pathlib import Path
          from collections import defaultdict

          ERROR_LOG = "build_error_logs/build_output.txt"
          OUTPUT = "build_error_logs/error_files.txt"
          REPO_ROOT = os.getcwd()

          print(f"Repository root: {REPO_ROOT}")

          # Read error log
          with open(ERROR_LOG, 'r', encoding='utf-8', errors='ignore') as f:
              error_log = f.read()

          # Dictionary to store file -> [(line_num, error_msg)]
          error_map = defaultdict(list)

          def normalize_path(filepath):
              """Normalize file path to be relative to repo root"""
              # Remove file:// prefix
              filepath = re.sub(r'^file:/+', '', filepath)
              
              # Remove leading slashes
              filepath = filepath.lstrip('/')
              
              # Extract relative path from GitHub Actions workspace path
              # Pattern: /home/runner/work/REPO_NAME/REPO_NAME/actual/path
              match = re.search(r'/home/runner/work/[^/]+/[^/]+/(.+)', filepath)
              if match:
                  filepath = match.group(1)
              
              # Also handle pattern: home/runner/work/REPO_NAME/REPO_NAME/actual/path (no leading /)
              match = re.search(r'home/runner/work/[^/]+/[^/]+/(.+)', filepath)
              if match:
                  filepath = match.group(1)
              
              return filepath

          # Pattern for Kotlin errors: e: file:///path/to/file.kt:line:col error message
          kt_pattern = r'e:\s+(?:file://)?([^\s:]+\.kt):(\d+):(\d+)\s+(.+)'
          for match in re.finditer(kt_pattern, error_log):
              filepath = normalize_path(match.group(1))
              line_num = int(match.group(2))
              error_msg = match.group(4).strip()
              error_map[filepath].append((line_num, error_msg))

          # Pattern for Java errors
          java_pattern = r'([a-zA-Z0-9_./\-]+\.java):(\d+):\s+error:\s+(.+)'
          for match in re.finditer(java_pattern, error_log):
              filepath = normalize_path(match.group(1))
              line_num = int(match.group(2))
              error_msg = match.group(3).strip()
              error_map[filepath].append((line_num, error_msg))

          # Pattern for XML errors
          xml_pattern = r'([a-zA-Z0-9_./\-]+\.xml):(\d+):(\d+):\s+(.+)'
          for match in re.finditer(xml_pattern, error_log):
              filepath = normalize_path(match.group(1))
              line_num = int(match.group(2))
              error_msg = match.group(4).strip()
              error_map[filepath].append((line_num, error_msg))

          # Pattern for C++ errors
          cpp_pattern = r'([a-zA-Z0-9_./\-]+\.(cpp|c|h|hpp)):(\d+):(\d+):\s+error:\s+(.+)'
          for match in re.finditer(cpp_pattern, error_log):
              filepath = normalize_path(match.group(1))
              line_num = int(match.group(3))
              error_msg = match.group(5).strip()
              error_map[filepath].append((line_num, error_msg))

          print(f"\nDetected {len(error_map)} error file(s)")

          # Write output
          with open(OUTPUT, 'w', encoding='utf-8') as out:
              out.write("==== SOURCE CODE (ERROR FILES WITH HIGHLIGHTED LINES) ====\n\n")
              
              if not error_map:
                  out.write("No error files detected\n")
              else:
                  for filepath in sorted(error_map.keys()):
                      print(f"Processing: {filepath}")
                      
                      # Construct actual file path
                      actual_path = os.path.join(REPO_ROOT, filepath)
                      
                      if not os.path.isfile(actual_path):
                          print(f"  ⚠️  File not found at: {actual_path}")
                          out.write(f"//===== FILE: {filepath} (NOT FOUND) =====\n")
                          out.write(f"// Expected at: {actual_path}\n\n")
                          continue
                      
                      print(f"  ✅ Found at: {actual_path}")
                      out.write(f"//===== FILE: {filepath} =====\n\n")
                      
                      # Write error summary
                      errors = sorted(set(error_map[filepath]))
                      out.write(f"// ❌ ERRORS IN THIS FILE ({len(errors)} error(s)):\n")
                      for line_num, msg in errors:
                          out.write(f"// Line {line_num}: {msg}\n")
                      out.write("\n")
                      
                      # Create set of error lines for quick lookup
                      error_lines = {line_num for line_num, _ in errors}
                      
                      # Write file content with line numbers and markers
                      try:
                          with open(actual_path, 'r', encoding='utf-8', errors='ignore') as f:
                              for line_num, line in enumerate(f, 1):
                                  # Remove trailing newline for consistent formatting
                                  line = line.rstrip('\n\r')
                                  if line_num in error_lines:
                                      out.write(f"{line_num:4d} ❌ {line}\n")
                                  else:
                                      out.write(f"{line_num:4d}    {line}\n")
                          print(f"  ✅ Extracted {line_num} lines")
                      except Exception as e:
                          print(f"  ❌ Error reading file: {e}")
                          out.write(f"// Error reading file: {e}\n")
                      
                      out.write("\n\n")

          # Save list of error files
          with open("build_error_logs/error_file_list.txt", 'w') as f:
              for filepath in sorted(error_map.keys()):
                  f.write(f"{filepath}\n")

          print(f"\n✅ Error extraction complete")
          print(f"Error files written to: {OUTPUT}")

          PYTHON_SCRIPT

      # ---------------- COMMIT ERROR REPORT WITH CONFLICT HANDLING ----------------
      - name: Commit & push error report (with conflict resolution)
        if: steps.gradle_build.outputs.exit_code != '0'
        run: |
          git config user.name "build-error-bot"
          git config user.email "bot@users.noreply.github.com"
          
          # Add changes
          git add build_error_logs/
          
          # Try to commit
          if git commit -m "Build failed - error report (exit code: ${{ steps.gradle_build.outputs.exit_code }})"; then
            echo "Changes committed successfully"
            
            # Try to push with retry logic
            MAX_RETRIES=3
            RETRY_COUNT=0
            PUSH_SUCCESS=false
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if git push origin main; then
                echo "✅ Push successful"
                PUSH_SUCCESS=true
                break
              else
                echo "⚠️ Push failed, attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES"
                RETRY_COUNT=$((RETRY_COUNT + 1))
                
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "Pulling latest changes and retrying..."
                  
                  # Stash our commit temporarily
                  git reset --soft HEAD^
                  git stash
                  
                  # Pull with rebase
                  git pull --rebase origin main || {
                    echo "Pull failed, trying merge strategy"
                    git rebase --abort 2>/dev/null || true
                    git pull origin main
                  }
                  
                  # Restore our changes
                  git stash pop || true
                  git add build_error_logs/
                  git commit -m "Build failed - error report (exit code: ${{ steps.gradle_build.outputs.exit_code }})" || true
                  
                  # Wait a bit before retry
                  sleep 2
                fi
              fi
            done
            
            if [ "$PUSH_SUCCESS" = false ]; then
              echo "⚠️ Push failed after $MAX_RETRIES attempts, but continuing anyway"
              echo "Error logs are still available in the job artifacts"
            fi
          else
            echo "No changes to commit or commit failed"
          fi

      # ---------------- UPLOAD ERROR LOGS AS ARTIFACT (FALLBACK) ----------------
      - name: Upload error logs as artifact
        if: steps.gradle_build.outputs.exit_code != '0'
        uses: actions/upload-artifact@v4
        with:
          name: build-error-logs
          path: build_error_logs/
          retention-days: 30

      # ---------------- FAIL THE JOB ----------------
      - name: Mark build as failed
        if: steps.gradle_build.outputs.exit_code != '0'
        run: |
          echo "::error::Build failed with exit code ${{ steps.gradle_build.outputs.exit_code }}"
          echo "Check build_error_logs/error_summary.txt for details"
          echo "Error logs also available as workflow artifact: build-error-logs"
          exit 1


//===== FILE: .github/workflows/Setup.yml =====
name: Setup Android (Kotlin DSL) + Gradle 8.4

on:
  workflow_dispatch:

permissions:
  contents: write

jobs:
  setup:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      # -------------------------
      # Java 17
      # -------------------------
      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 17
          cache: gradle

      # -------------------------
      # Android SDK
      # -------------------------
      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Accept Android SDK licenses
        run: yes | sdkmanager --licenses

      # -------------------------
      # Sanity check (Kotlin DSL)
      # -------------------------
      - name: Check Gradle files
        run: |
          test -f build.gradle.kts || (echo "❌ build.gradle.kts not found" && exit 1)
          test -f settings.gradle.kts || (echo "❌ settings.gradle.kts not found" && exit 1)

      # -------------------------
      # Force Gradle 8.4
      # -------------------------
      - name: Generate Gradle Wrapper 8.4
        run: |
          curl -sLo gradle.zip https://services.gradle.org/distributions/gradle-8.4-bin.zip
          unzip -q gradle.zip
          ./gradle-8.4/bin/gradle wrapper --gradle-version 8.4

      - name: Make gradlew executable
        run: chmod +x gradlew

      # -------------------------
      # Verify
      # -------------------------
      - name: Verify Gradle
        run: ./gradlew --version

      # -------------------------
      # Commit wrapper
      # -------------------------
      - name: Commit Gradle Wrapper
        run: |
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add gradlew gradlew.bat gradle/wrapper
          git diff --cached --quiet || git commit -m "Add Gradle wrapper 8.4 (Kotlin DSL, Java 17)"
          git push


//===== FILE: .github/workflows/main.yml =====
name: Extract Repo Source to TXT

on:
  workflow_run:
    workflows: ["AI Code Generator"]
    types:
      - completed
  workflow_dispatch:
  push:
    branches: [ main ]

permissions:
  contents: write

jobs:
  extract:
    runs-on: ubuntu-latest

    # Run on:
    # - manual run
    # - push
    # - workflow_run ONLY if previous workflow succeeded
    if: ${{ success() && (github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success') }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Generate file tree + source dump
        run: python extract_repo_to_txt.py

      - name: Commit & push
        run: |
          git config user.name "repo-source-bot"
          git config user.email "bot@users.noreply.github.com"
          git add repo_source_dump.txt
          git commit -m "Auto: repo file tree + source dump" || echo "No changes"
          git push

